#!/usr/bin/env python3
import argparse
from collections import (
    OrderedDict,
)
import json
from pathlib import (
    Path,
)
import sys
from typing import (
    Any,
    Dict,
    Iterable,
    Iterator,
    List,
    Set,
    TypeVar,
)
import warnings

import vyper
from vyper.parser import (
    parser_utils,
)
from vyper.settings import (
    VYPER_TRACEBACK_LIMIT,
)
from vyper.signatures.interface import (
    extract_file_interface_imports,
)
from vyper.typing import (
    ContractCodes,
    ContractName,
)

warnings.simplefilter('always')

format_options_help = """Format to print, one or more of:
 bytecode (default) - Deployable bytecode
 bytecode_runtime   - Bytecode at runtime
 abi                - ABI in JSON format
 abi_python         - ABI in python format
 ast                - AST in JSON format
 source_map         - Vyper source map
 method_identifiers - Dictionary of method signature to method identifier.
 combined_json      - All of the above format options combined as single JSON output.
 interface          - Print Vyper interface of a contract
 external_interface - Print Externa Contract of a contract, to be used as outside contract calls.
 opcodes            - List of opcodes as a string
 opcodes_runtime    - List of runtime opcodes as a string
"""

parser = argparse.ArgumentParser(
    description='Vyper programming language for Ethereum',
    formatter_class=argparse.RawTextHelpFormatter
)
parser.add_argument(
    'input_files',
    help='Vyper sourcecode to compile',
    nargs='+',
)
parser.add_argument(
    '--version',
    action='version',
    version='{0}+commit.{1}'.format(vyper.__version__, vyper.__commit__),
)
parser.add_argument(
    '--show-gas-estimates',
    help='Show gas estimates in ir output mode.',
    action="store_true",
)
parser.add_argument(
    '-f',
    help=format_options_help,
    default='bytecode', dest='format',
)
parser.add_argument(
    '--traceback-limit',
    help='Set the traceback limit for error messages reported by the compiler',
    type=int,
)
parser.add_argument(
    '-p',
    help='Set the root path for contract imports',
    default='.', dest='root_path'
)

args = parser.parse_args()

if args.traceback_limit is not None:
    sys.tracebacklimit = args.traceback_limit
elif VYPER_TRACEBACK_LIMIT is not None:
    sys.tracebacklimit = VYPER_TRACEBACK_LIMIT
else:
    # Python usually defaults sys.tracebacklimit to 1000.  We use a default
    # setting of zero so error printouts only include information about where
    # an error occurred in a Vyper source file.
    sys.tracebacklimit = 0


T = TypeVar('T')


def uniq(seq: Iterable[T]) -> Iterator[T]:
    """
    Yield unique items in ``seq`` in order.
    """
    seen: Set[T] = set()

    for x in seq:
        if x in seen:
            continue

        seen.add(x)
        yield x


def exc_handler(contract_name: ContractName, exception: Exception) -> None:
    print('Error compiling: ', contract_name)
    raise exception


def get_interface_codes(root_path: Path, codes: ContractCodes) -> Any:
    interface_codes: Dict = {}
    interfaces: Dict = {}

    for file_path, code in codes.items():
        interfaces[file_path] = {}
        parent_path = root_path.joinpath(file_path).parent

        interface_codes = extract_file_interface_imports(code)
        for interface_name, interface_path in interface_codes.items():

            base_paths = [parent_path]
            if not interface_path.startswith('.'):
                base_paths.append(root_path)
            elif interface_path.startswith('../') and parent_path == root_path:
                raise FileNotFoundError(
                    f"{file_path} - Cannot perform relative import outside of base folder"
                )

            valid_path = get_interface_file_path(base_paths, interface_path)
            with valid_path.open() as fh:
                code = fh.read()
                if valid_path.suffix == '.json':
                    interfaces[file_path][interface_name] = {
                        'type': 'json',
                        'code': json.loads(code.encode())
                    }
                else:
                    interfaces[file_path][interface_name] = {
                        'type': 'vyper',
                        'code': code
                    }

    return interfaces


def get_interface_file_path(base_paths: List, import_path: str) -> Path:
    relative_path = Path(import_path)
    for path in base_paths:
        file_path = path.joinpath(relative_path)
        try:
            suffix = next(i for i in ('.vy', '.json') if file_path.with_suffix(i).exists())
            return file_path.with_suffix(suffix)
        except StopIteration:
            continue
    raise Exception(
        f'Imported interface "{import_path}{{.vy,.json}}" does not exist.'
    )


if __name__ == '__main__':
    if args.show_gas_estimates:
        parser_utils.LLLnode.repr_show_gas = True

    root_path = Path(args.root_path).resolve()
    if not root_path.exists():
        raise FileNotFoundError(f"Invalid root path - '{root_path.as_posix()}' does not exist")

    codes: ContractCodes = OrderedDict()
    for file_name in args.input_files:
        file_path = Path(file_name).resolve()
        file_str = file_path.relative_to(root_path).as_posix()
        with file_path.open() as fh:
            codes[file_str] = fh.read()

    # Combined json output
    if args.format == 'combined_json':
        out = vyper.compile_codes(
            codes,
            ['bytecode', 'bytecode_runtime', 'abi', 'source_map', 'method_identifiers'],
            exc_handler=exc_handler,
            interface_codes=get_interface_codes(root_path, codes)
        )
        out['version'] = vyper.__version__
        print(json.dumps(out))

    else:  # Normal output.
        translate_map = {
            'abi_python': 'abi',
            'json': 'abi',
            'ast': 'ast_dict'
        }
        formats = []
        orig_args = tuple(uniq(args.format.split(',')))

        for f in orig_args:
            formats.append(translate_map.get(f, f))

        out_list = list(vyper.compile_codes(
            codes,
            formats,
            exc_handler=exc_handler,
            interface_codes=get_interface_codes(root_path, codes)
        ).values())

        for out in out_list:
            for f in orig_args:
                o = out[translate_map.get(f, f)]
                if f in ('abi', 'json', 'ast'):
                    print(json.dumps(o))
                elif f == 'abi_python':
                    print(o)
                elif f == 'source_map':
                    print(json.dumps(o))
                else:
                    print(o)
